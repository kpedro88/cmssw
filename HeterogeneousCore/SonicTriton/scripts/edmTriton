#!/bin/bash

# defaults
USEDOCKER=""
GPU=""
VERBOSE=""
WTIME=60
SERVER=triton_server_instance
RETRIES=3
REPOS=()
MODELS=()
FORCE=""
CLEANUP=true

usage() {
	ECHO="echo -e"
	$ECHO "edmTriton [options] [start|stop]"
	$ECHO
	$ECHO "Options:"
	$ECHO "-c               \t don't cleanup temporary dir (for debugging)"
	$ECHO "-d               \t use Docker instead of Singularity"
	$ECHO "-f               \t force reuse of (possibly) existing container instance"
	$ECHO "-g               \t use GPU instead of CPU"
	$ECHO "-M [dir,dir,...] \t comma-separated list of model repositories"
	$ECHO "-m [dir,dir,...] \t comma-separated list of specific model directories"
	$ECHO "-n [name]        \t name of container instance, also used for hidden temporary dir (default: ${SERVER})"
	$ECHO "-r [num]         \t number of retries when starting container (default: ${RETRIES})"
	$ECHO "-v               \t (verbose) start: activate server debugging info; stop: keep server logs"
	$ECHO "-w [time]        \t maximum time to wait for server to start (default: ${WTIME} seconds)"
	$ECHO "-h               \t print this message and exit"
	$ECHO
	$ECHO "Operations:"
	$ECHO "start            \t start server"
	$ECHO "stop             \t stop server"
	exit $1
}

# check shm locations
SHM=/dev/shm
if [ -e /run/shm ]; then
	SHM=/run/shm
fi

while getopts "cdfgM:m:n:r:vw:h" opt; do
	case "$opt" in
		c) CLEANUP=""
		;;
		d) USEDOCKER=true
		;;
		f) FORCE=true
		;;
		g) GPU=true
		;;
		M) IFS="," read -a REPOS <<< "$OPTARG"
		;;
		m) IFS="," read -a MODELS <<< "$OPTARG"
		;;
		n) SERVER="$OPTARG"
		;;
		r) RETRIES="$OPTARG"
		;;
		v) VERBOSE="--log-verbose=1 --log-error=1 --log-info=1"
		;;
		w) WTIME="$OPTARG"
		;;
		h) usage 0
		;;
	esac
done

shift $(($OPTIND - 1))
OP=$1

if [ "$OP" != start ] && [ "$OP" != stop ]; then
	usage 1
fi

if [ "$RETRIES" -le 0 ]; then
	RETRIES=1
fi

TOPDIR=$PWD
TMPDIR=".${SERVER}"
DOCKER="sudo docker"
IMAGE=fastml/triton-torchgeo:20.09-py3-geometric
MODELREPO="models"
MODELDIR="$TOPDIR"/"$TMPDIR"/"$MODELREPO"
LOG="log_${SERVER}.log"
LIB=lib
STARTED_INDICATOR="Started GRPCInferenceService"
EXTRA=""

start_docker(){
	# mount all model directories
	MOUNTS=""
	for MODEL in ${MODELS[@]}; do
		MOUNTS="$MOUNTS -v$MODEL:$MODEL"
	done

	$DOCKER run -d --name ${SERVER} \
		--shm-size=1g --ulimit memlock=-1 --ulimit stack=67108864 \
		-p8000:8000 -p8001:8001 -p8002:8002 $EXTRA \
		-v"${MODELDIR}":/models $MOUNTS \
		${IMAGE} tritonserver --model-repository=/models $VERBOSE
}

start_singularity(){
	# triton server image may need to modify contents of opt/tritonserver/lib/
	# but cvmfs is read-only
	# -> make a writable local directory with the same contents
	mkdir ${LIB}
	ln -s /cvmfs/unpacked.cern.ch/registry.hub.docker.com/${IMAGE}/opt/tritonserver/lib/* ${LIB}/

	# mount all model directories
	MOUNTS=""
	for MODEL in ${MODELS[@]}; do
		MOUNTS="$MOUNTS -B $MODEL"
	done

	# start instance
	# need to bind /cvmfs for above symlinks to work inside container
	singularity instance start \
		-B ${SHM}:/run/shm -B "${MODELDIR}":/models -B ${LIB}:/opt/tritonserver/lib -B /cvmfs $MOUNTS $EXTRA \
		/cvmfs/unpacked.cern.ch/registry.hub.docker.com/${IMAGE} ${SERVER}

	START_EXIT=$?
	if [ "$START_EXIT" -ne 0 ]; then
		rm -rf ${LIB}
		return "$START_EXIT"
	fi

	# run the actual server
	singularity run instance://${SERVER} \
		tritonserver --model-repository=/models $VERBOSE >& ${LOG} &
}

stop_docker(){
	# keep log (outside of tmp dir)
	if [ -n "$VERBOSE" ]; then $DOCKER logs ${SERVER} >& "${TOPDIR}/${LOG}"; fi

	$DOCKER stop ${SERVER}
	$DOCKER rm ${SERVER}
}

stop_singularity(){
	singularity instance stop ${SERVER}

	# move log out of tmp dir
	if [ -n "$VERBOSE" ]; then mv "$LOG" "$TOPDIR"; fi
}

test_docker(){
	# docker logs print to stderr
	${DOCKER} logs ${SERVER} |& grep "$STARTED_INDICATOR"
}

test_singularity(){
	grep "$STARTED_INDICATOR" $LOG
}

wait_server(){
	COUNT=0
	while ! $WAIT_COND >& /dev/null; do
		if [ "$COUNT" -gt "$WTIME" ]; then
			echo "timed out waiting for server to start"
			VERBOSE=true $STOP_FN
			cleanup
			exit 1
		else
			COUNT=$(($COUNT + 1))
			sleep 1
		fi
	done

	echo "server is ready!"
	exit 0
}

cleanup(){
	if [ -n "$CLEANUP" ]; then
		cd "$TOPDIR"
		rm -rf "$TMPDIR"
	fi
}

assemble_models(){
	# assemble repository by linking model directories
	mkdir "$MODELREPO"
	for REPO in ${REPOS[@]}; do
		for MODEL in "$REPO"/*/; do
			MODELS+=("$MODEL")
		done
	done
	for ((m=0; m < ${#MODELS[@]}; m++)); do
		# avoid issues w/ multiple levels of symlinks
		MODELS[$m]=$(readlink -f ${MODELS[$m]})
		ln -s "${MODELS[$m]}" "$MODELREPO"/$(basename "${MODELS[$m]}")
	done
}

if [ -n "$USEDOCKER" ]; then
	if [ -n "$GPU" ]; then
		EXTRA="--gpus all"
	fi
	START_FN=start_docker
	WAIT_COND=test_docker
	STOP_FN=stop_docker
	PROG_NAME=Docker
else
	if [ -n "$GPU" ]; then
		EXTRA="--nv"
	fi
	START_FN=start_singularity
	WAIT_COND=test_singularity
	STOP_FN=stop_singularity
	PROG_NAME=Singularity
fi

if [ "$OP" == start ]; then
	# handle cleaning up
	if [ -n "$FORCE" ]; then
		$STOP_FN
		cleanup
	elif [ -d "$TMPDIR" ]; then
		echo "Error: this container may already exist (override with -f)"
		exit 1
	fi

	# make sure everything happens in tmp dir
	mkdir "$TMPDIR"
	cd "$TMPDIR"

	assemble_models

	START_EXIT=""
	for ((counter=0; counter < ${RETRIES}; counter++)); do
		$START_FN
		START_EXIT=$?
		if [ "$START_EXIT" -eq 0 ]; then
			break
		else
			echo "Retrying after container issue..."
			$STOP_FN
		fi
	done
	if [ "$START_EXIT" -ne 0 ]; then
		echo "Error from $PROG_NAME"
		exit "$START_EXIT"
	fi
	wait_server
else
	# check for tmp dir
	if [ -d "$TMPDIR" ]; then
		cd "$TMPDIR"
	else
		echo "Error: attempt to stop unknown container $SERVER"
		exit 1
	fi

	$STOP_FN
	cleanup
fi
